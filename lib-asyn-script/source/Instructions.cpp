
/*!
 * \file Instructions.cpp
 * \date 12-21-2016 10:51:17
 * 
 * 
 * \author cs (04nycs@gmail.com)
 * https://github.com/ThinEureka/asyn-script
 */

#include "Instructions.h"
#include "Function.h"

asys::BreakPoint& asys::BreakPoint::operator()(const std::function<void(Machine*, const BreakPoint&)>& callback, const char* fileName /*= nullptr*/, const char* functionName /*= nullptr*/, int lineNumber /*= -1*/)
{
	m_callback = callback;
	m_fileName = fileName;
	m_functionName = functionName;
	if (m_lineNumber == -1)
	{
		m_lineNumber = lineNumber;
	}

	return *this;
}

asys::BreakPoint& asys::BreakPoint::operator>>= (const VariableList& variableList)
{
	CallInstruction* callInstruction = dynamic_cast<CallInstruction*>(m_instruction);
	if (callInstruction)
	{
		callInstruction->setOutputs(variableList);
	}

	int numOutputVariable = 0;
	for (size_t i = 0; i < variableList.getLength(); ++i)
	{
		auto var = variableList.getAsysVariable(i);
		auto variableType = var->getVariableType();

		//do not use CC in the right side of CALL statements, because a variable generated by CC means to be a "right value".
		assert(variableType != VariableType::right);

		if (variableType == VariableType::output)
		{
			++numOutputVariable;
		}
	}

	callInstruction->parentFunctionCode->movePendingOutputInstructions(numOutputVariable, lineNumber());

	return *this;
}
